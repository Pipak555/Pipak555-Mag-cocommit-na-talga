import{q as t,c as e,w as a,d as o,f as s,e as n,u as i}from"./firebase-vendor-BtzXZj7S.js";import{j as r,H as c,N as d,O as l,P as u}from"./index-Bl4WVUm9.js";const p=async(d,p="wallet")=>{try{const{guestId:y,totalPrice:g,id:h}=d;if(!y||!g||0>=g)throw Error("Invalid booking data for payment processing");const I=await s(n(r,"users",y));if(!I.exists())throw Error("Guest user not found");const b=I.data(),k=b.walletBalance||0;let B=k;if("paypal"===p){if(!b.paypalEmail)throw Error("PayPal account not linked. Please link your PayPal account in the wallet settings before making payments.");if(!b.paypalEmailVerified)throw Error("PayPal account not verified. Please verify your PayPal account in the wallet settings before making payments.");const s=t(e(r,"transactions"),a("bookingId","==",h),a("type","==","payment"),a("paymentMethod","==","paypal"),a("status","==","completed"));if((await o(s)).empty)throw Error("PayPal payment not found. Please complete the PayPal payment first.")}else{if(g>k)throw Error(`Insufficient wallet balance. Required: ₱${g.toFixed(2)}, Available: ₱${k.toFixed(2)}. Please use PayPal to complete the payment.`);B=k-g,await i(n(r,"users",y),{walletBalance:B})}const P=.1*g,E=g-P;"wallet"===p&&await c({userId:y,type:"payment",amount:g,description:"Booking payment for booking #"+h.slice(0,8),status:"completed",paymentMethod:"wallet",bookingId:h,serviceFee:P,netAmount:E});const v=await s(n(r,"users",d.hostId));if(!v.exists())throw Error("Host user not found");const x=(v.data().walletBalance||0)+E;if(await i(n(r,"users",d.hostId),{walletBalance:x}),await c({userId:d.hostId,type:"deposit",amount:E,description:`Earnings from booking #${h.slice(0,8)} (after 10% service fee)`,status:"completed",bookingId:h,serviceFee:P,grossAmount:g}),await c({userId:"platform",type:"deposit",amount:P,description:"Service fee from booking #"+h.slice(0,8),status:"completed",paymentMethod:"service_fee",bookingId:h,guestId:y,hostId:d.hostId}),d.couponCode&&b.coupons)try{const t=b.coupons.map(t=>t.code!==d.couponCode||t.used?t:{...t,used:!0,usedAt:(new Date).toISOString(),usedForBookingId:h});await i(n(r,"users",y),{coupons:t})}catch(w){}try{const t=b.points||0,e=50,a=t+e;await i(n(r,"users",y),{points:a}),await c({userId:y,type:"reward",amount:e,description:"Points earned for booking #"+h.slice(0,8),status:"completed",bookingId:h})}catch(f){}try{const t=await s(n(r,"listing",d.listingId)),e=t.exists()?t.data().title:"Your booking";await u(y,h,e),await l(y,h,g,"completed")}catch(m){}return{success:!0,guestNewBalance:B,hostNewBalance:x,serviceFee:P,netToHost:E}}catch(y){throw y}},w=async(u,p,w)=>{try{const{guestId:y,hostId:g,totalPrice:h,id:I,status:b}=u;if(!(y&&g&&h&&h>0))throw Error("Invalid booking data for refund processing");const k=t(e(r,"transactions"),a("bookingId","==",I),a("type","==","payment"),a("status","==","completed"));if((await o(k)).empty&&"pending"===b)return{success:!0,refundAmount:0,message:"No payment was made for this pending booking"};const B=.1*h,P=h-B,[E,v]=await Promise.all([s(n(r,"users",y)),s(n(r,"users",g))]);if(!E.exists()||!v.exists())throw Error("User not found for refund processing");const x=E.data(),A=v.data(),F=x.walletBalance||0,S=A.walletBalance||0;if(u.couponCode&&x.coupons)try{const t=x.coupons.map(t=>t.code===u.couponCode&&t.used&&t.usedForBookingId===I?{...t,used:!1,usedAt:void 0,usedForBookingId:void 0}:t);await i(n(r,"users",y),{coupons:t})}catch(f){}const $=F+h;await i(n(r,"users",y),{walletBalance:$});let N=S;P>S||(N=S-P,await i(n(r,"users",g),{walletBalance:N})),await c({userId:y,type:"refund",amount:h,description:`Refund for cancelled booking #${I.slice(0,8)} (cancelled by ${p})${w?": "+w:""}`,status:"completed",bookingId:I,cancelledBy:p}),P>S||await c({userId:g,type:"withdrawal",amount:P,description:"Refund deduction for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:p});const O=t(e(r,"transactions"),a("bookingId","==",I),a("type","==","deposit"),a("userId","==","platform"));(await o(O)).empty||await c({userId:"platform",type:"withdrawal",amount:B,description:"Service fee refund for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:p});try{const t=await s(n(r,"listing",u.listingId)),e=t.exists()?t.data().title:"Your booking";await d(y,I,e,p),await l(y,I,h,"refunded")}catch(m){}return{success:!0,guestNewBalance:$,hostNewBalance:N,refundAmount:h,serviceFeeRefund:B}}catch(y){throw y}},f=async(t,e,a)=>{try{if("refunded"===e.status)throw Error("Transaction has already been refunded");if("completed"!==e.status)throw Error("Only completed transactions can be refunded");const{userId:o,amount:d,type:l,bookingId:u}=e,p=await s(n(r,"users",o));if(!p.exists())throw Error("User not found");const f=p.data().walletBalance||0;if("payment"===l&&u){const t=await s(n(r,"bookings",u));if(t.exists()){const e={id:t.id,...t.data()};return await w(e,"admin",a)}}const m=f+d;return await i(n(r,"users",o),{walletBalance:m}),await c({userId:o,type:"refund",amount:d,description:`Refund for transaction #${t.slice(0,8)}${a?": "+a:""} (admin refund)`,status:"completed",originalTransactionId:t}),await i(n(r,"transactions",t),{status:"refunded",refundedAt:(new Date).toISOString(),refundReason:a}),{success:!0,newBalance:m,refundAmount:d}}catch(o){throw o}},m=async t=>{try{const e=await s(n(r,"transactions",t));if(!e.exists())throw Error("Transaction not found");const a=e.data();if("pending"!==a.status)throw Error("Only pending transactions can be confirmed");if("payment"===a.type&&a.bookingId){const t=await s(n(r,"bookings",a.bookingId));if(t.exists()){const e={id:t.id,...t.data()};await p(e)}}else{const t=await s(n(r,"users",a.userId));if(t.exists()){const e=(t.data().walletBalance||0)+("deposit"===a.type||"reward"===a.type?a.amount:-a.amount);await i(n(r,"users",a.userId),{walletBalance:e})}}return await i(n(r,"transactions",t),{status:"completed",confirmedAt:(new Date).toISOString()}),{success:!0}}catch(e){throw e}};export{p as a,f as b,m as c,w as p};
