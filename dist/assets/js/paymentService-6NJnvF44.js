const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/js/hostPointsService-BCZ7eKj5.js","assets/js/firebase-vendor-BC71bXmb.js","assets/js/index-BnushFQy.js","assets/js/react-vendor-Ve3SFwKO.js","assets/js/utils-vendor-DzY7Ay74.js","assets/js/maps-vendor-CYGXCXz5.js","assets/maps-vendor-Dgihpmma.css","assets/js/ui-vendor-D9RGQy8n.js","assets/js/icons-vendor-DD8ZfUKZ.js","assets/index-CZT-s-DH.css"])))=>i.map(i=>d[i]);
import{j as t,y as a,Q as e,R as o,_ as s,S as n}from"./index-BnushFQy.js";import{q as i,d as r,w as c,e as d,h as u,f as l,u as w}from"./firebase-vendor-BC71bXmb.js";const p=async(e,p="wallet")=>{try{const{guestId:g,totalPrice:h,id:I}=e;if(!g||!h||0>=h)throw Error("Invalid booking data for payment processing");const k=await u(l(t,"users",g));if(!k.exists())throw Error("Guest user not found");const b=k.data(),P=b.walletBalance||0;let B=P;if("paypal"===p){if(!b.paypalEmail)throw Error("PayPal account not linked. Please link your PayPal account in the wallet settings before making payments.");if(!b.paypalEmailVerified)throw Error("PayPal account not verified. Please verify your PayPal account in the wallet settings before making payments.");const a=i(r(t,"transactions"),c("bookingId","==",I),c("type","==","payment"),c("paymentMethod","==","paypal"),c("status","==","completed"));if((await d(a)).empty)throw Error("PayPal payment not found. Please complete the PayPal payment first.")}else{if(h>P)throw Error(`Insufficient wallet balance. Required: ₱${h.toFixed(2)}, Available: ₱${P.toFixed(2)}. Please use PayPal to complete the payment.`);B=P-h,await w(l(t,"users",g),{walletBalance:B})}"wallet"===p&&await a({userId:g,type:"payment",amount:h,description:"Booking payment for booking #"+I.slice(0,8),status:"completed",paymentMethod:"wallet",bookingId:I});const E=await u(l(t,"users",e.hostId));if(!E.exists())throw Error("Host user not found");const x=(E.data().walletBalance||0)+h;await w(l(t,"users",e.hostId),{walletBalance:x}),await a({userId:e.hostId,type:"deposit",amount:h,description:"Earnings from booking #"+I.slice(0,8),status:"completed",bookingId:I,payoutStatus:"pending"});try{const{awardHostPointsForBooking:t}=await s(async()=>{const{awardHostPointsForBooking:t}=await import("./hostPointsService-BCZ7eKj5.js");return{awardHostPointsForBooking:t}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]));await t(e.hostId,I,h)}catch(f){}if(e.couponCode&&b.coupons)try{const a=b.coupons.map(t=>t.code!==e.couponCode||t.used?t:{...t,used:!0,usedAt:(new Date).toISOString(),usedForBookingId:I});await w(l(t,"users",g),{coupons:a})}catch(y){}try{const e=b.points||0,o=50,s=e+o;await w(l(t,"users",g),{points:s}),await a({userId:g,type:"reward",amount:o,description:"Points earned for booking #"+I.slice(0,8),status:"completed",bookingId:I})}catch(f){}try{const a=await u(l(t,"listing",e.listingId)),s=a.exists()?a.data().title:"Your booking";await n(g,I,s),await o(g,I,h,"completed")}catch(m){}return{success:!0,guestNewBalance:B,hostNewBalance:x}}catch(g){throw g}},f=async(s,n,p)=>{try{const{guestId:m,hostId:g,totalPrice:h,id:I,status:k}=s;if(!(m&&g&&h&&h>0))throw Error("Invalid booking data for refund processing");const b=i(r(t,"transactions"),c("bookingId","==",I),c("type","==","payment"),c("status","==","completed"));if((await d(b)).empty&&"pending"===k)return{success:!0,refundAmount:0,message:"No payment was made for this pending booking"};const[P,B]=await Promise.all([u(l(t,"users",m)),u(l(t,"users",g))]);if(!P.exists()||!B.exists())throw Error("User not found for refund processing");const E=P.data(),x=B.data(),v=E.walletBalance||0,A=x.walletBalance||0;if(s.couponCode&&E.coupons)try{const a=E.coupons.map(t=>t.code===s.couponCode&&t.used&&t.usedForBookingId===I?{...t,used:!1,usedAt:void 0,usedForBookingId:void 0}:t);await w(l(t,"users",m),{coupons:a})}catch(f){}const S=v+h;await w(l(t,"users",m),{walletBalance:S});let F=A;h>A||(F=A-h,await w(l(t,"users",g),{walletBalance:F})),await a({userId:m,type:"refund",amount:h,description:`Refund for cancelled booking #${I.slice(0,8)} (cancelled by ${n})${p?": "+p:""}`,status:"completed",bookingId:I,cancelledBy:n}),h>A||await a({userId:g,type:"withdrawal",amount:h,description:"Refund deduction for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:n});try{const a=await u(l(t,"listing",s.listingId)),i=a.exists()?a.data().title:"Your booking";await e(m,I,i,n),await o(m,I,h,"refunded")}catch(y){}return{success:!0,guestNewBalance:S,hostNewBalance:F,refundAmount:h}}catch(m){throw m}},y=async(e,o,s)=>{try{if("refunded"===o.status)throw Error("Transaction has already been refunded");if("completed"!==o.status)throw Error("Only completed transactions can be refunded");const{userId:n,amount:i,type:r,bookingId:c}=o,d=await u(l(t,"users",n));if(!d.exists())throw Error("User not found");const p=d.data().walletBalance||0;if("payment"===r&&c){const a=await u(l(t,"bookings",c));if(a.exists()){const t={id:a.id,...a.data()};return await f(t,"admin",s)}}const y=p+i;return await w(l(t,"users",n),{walletBalance:y}),await a({userId:n,type:"refund",amount:i,description:`Refund for transaction #${e.slice(0,8)}${s?": "+s:""} (admin refund)`,status:"completed",originalTransactionId:e}),await w(l(t,"transactions",e),{status:"refunded",refundedAt:(new Date).toISOString(),refundReason:s}),{success:!0,newBalance:y,refundAmount:i}}catch(n){throw n}},m=async a=>{try{const e=await u(l(t,"transactions",a));if(!e.exists())throw Error("Transaction not found");const o=e.data();if("pending"!==o.status)throw Error("Only pending transactions can be confirmed");if("payment"===o.type&&o.bookingId){const a=await u(l(t,"bookings",o.bookingId));if(a.exists()){const t={id:a.id,...a.data()};await p(t)}}else{const a=await u(l(t,"users",o.userId));if(a.exists()){const e=(a.data().walletBalance||0)+("deposit"===o.type||"reward"===o.type?o.amount:-o.amount);await w(l(t,"users",o.userId),{walletBalance:e})}}return await w(l(t,"transactions",a),{status:"completed",confirmedAt:(new Date).toISOString()}),{success:!0}}catch(e){throw e}};export{p as a,y as b,m as c,f as p};
