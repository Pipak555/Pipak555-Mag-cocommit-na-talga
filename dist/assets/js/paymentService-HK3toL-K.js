import{q as t,c as e,w as a,d as s,f as o,e as n,u as i}from"./firebase-vendor-CvoiOdvz.js";import{j as r,n as c,K as d,M as l,N as u}from"./index-BbvEjZj9.js";const w=async t=>{try{const{guestId:a,totalPrice:s,id:d}=t;if(!a||!s||0>=s)throw Error("Invalid booking data for payment processing");const w=await o(n(r,"users",a));if(!w.exists())throw Error("Guest user not found");const f=w.data().walletBalance||0;if(s>f)throw Error(`Insufficient wallet balance. Required: ₱${s.toFixed(2)}, Available: ₱${f.toFixed(2)}`);const p=.15*s,m=s-p,g=f-s;await i(n(r,"users",a),{walletBalance:g}),await c({userId:a,type:"payment",amount:s,description:"Booking payment for booking #"+d.slice(0,8),status:"completed",paymentMethod:"wallet",bookingId:d,serviceFee:p,netAmount:m});const y=await o(n(r,"users",t.hostId));if(!y.exists())throw Error("Host user not found");const I=(y.data().walletBalance||0)+m;await i(n(r,"users",t.hostId),{walletBalance:I}),await c({userId:t.hostId,type:"deposit",amount:m,description:`Earnings from booking #${d.slice(0,8)} (after 15% service fee)`,status:"completed",bookingId:d,serviceFee:p,grossAmount:s}),await c({userId:"platform",type:"deposit",amount:p,description:"Service fee from booking #"+d.slice(0,8),status:"completed",paymentMethod:"service_fee",bookingId:d,guestId:a,hostId:t.hostId});try{const e=await o(n(r,"listing",t.listingId)),i=e.exists()?e.data().title:"Your booking";await u(a,d,i),await l(a,d,s,"completed")}catch(e){}return{success:!0,guestNewBalance:g,hostNewBalance:I,serviceFee:p,netToHost:m}}catch(a){throw a}},f=async(u,w,f)=>{try{const{guestId:m,hostId:g,totalPrice:y,id:I,status:h}=u;if(!(m&&g&&y&&y>0))throw Error("Invalid booking data for refund processing");const b=t(e(r,"transactions"),a("bookingId","==",I),a("type","==","payment"),a("status","==","completed"));if((await s(b)).empty&&"pending"===h)return{success:!0,refundAmount:0,message:"No payment was made for this pending booking"};const k=.15*y,B=y-k,[x,v]=await Promise.all([o(n(r,"users",m)),o(n(r,"users",g))]);if(!x.exists()||!v.exists())throw Error("User not found for refund processing");const E=x.data(),A=v.data(),$=E.walletBalance||0,F=A.walletBalance||0,N=$+y;await i(n(r,"users",m),{walletBalance:N});let R=F;B>F||(R=F-B,await i(n(r,"users",g),{walletBalance:R})),await c({userId:m,type:"refund",amount:y,description:`Refund for cancelled booking #${I.slice(0,8)} (cancelled by ${w})${f?": "+f:""}`,status:"completed",bookingId:I,cancelledBy:w}),B>F||await c({userId:g,type:"withdrawal",amount:B,description:"Refund deduction for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:w});const S=t(e(r,"transactions"),a("bookingId","==",I),a("type","==","deposit"),a("userId","==","platform"));(await s(S)).empty||await c({userId:"platform",type:"withdrawal",amount:k,description:"Service fee refund for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:w});try{const t=await o(n(r,"listing",u.listingId)),e=t.exists()?t.data().title:"Your booking";await d(m,I,e,w),await l(m,I,y,"refunded")}catch(p){}return{success:!0,guestNewBalance:N,hostNewBalance:R,refundAmount:y,serviceFeeRefund:k}}catch(m){throw m}},p=async(t,e,a)=>{try{if("refunded"===e.status)throw Error("Transaction has already been refunded");if("completed"!==e.status)throw Error("Only completed transactions can be refunded");const{userId:s,amount:d,type:l,bookingId:u}=e,w=await o(n(r,"users",s));if(!w.exists())throw Error("User not found");const p=w.data().walletBalance||0;if("payment"===l&&u){const t=await o(n(r,"bookings",u));if(t.exists()){const e={id:t.id,...t.data()};return await f(e,"admin",a)}}const m=p+d;return await i(n(r,"users",s),{walletBalance:m}),await c({userId:s,type:"refund",amount:d,description:`Refund for transaction #${t.slice(0,8)}${a?": "+a:""} (admin refund)`,status:"completed",originalTransactionId:t}),await i(n(r,"transactions",t),{status:"refunded",refundedAt:(new Date).toISOString(),refundReason:a}),{success:!0,newBalance:m,refundAmount:d}}catch(s){throw s}},m=async t=>{try{const e=await o(n(r,"transactions",t));if(!e.exists())throw Error("Transaction not found");const a=e.data();if("pending"!==a.status)throw Error("Only pending transactions can be confirmed");if("payment"===a.type&&a.bookingId){const t=await o(n(r,"bookings",a.bookingId));if(t.exists()){const e={id:t.id,...t.data()};await w(e)}}else{const t=await o(n(r,"users",a.userId));if(t.exists()){const e=(t.data().walletBalance||0)+("deposit"===a.type||"reward"===a.type?a.amount:-a.amount);await i(n(r,"users",a.userId),{walletBalance:e})}}return await i(n(r,"transactions",t),{status:"completed",confirmedAt:(new Date).toISOString()}),{success:!0}}catch(e){throw e}};export{w as a,p as b,m as c,f as p};
