import{q as t,c as e,w as a,d as s,f as o,e as n,u as i}from"./firebase-vendor-BtzXZj7S.js";import{j as r,D as c,N as d,O as l,P as u}from"./index-F95ZJi6y.js";const w=async(d,w="wallet")=>{try{const{guestId:f,totalPrice:m,id:y}=d;if(!f||!m||0>=m)throw Error("Invalid booking data for payment processing");const g=await o(n(r,"users",f));if(!g.exists())throw Error("Guest user not found");const h=g.data(),I=h.walletBalance||0;let b=I;if("paypal"===w){if(!h.paypalEmail)throw Error("PayPal account not linked. Please link your PayPal account in the wallet settings before making payments.");if(!h.paypalEmailVerified)throw Error("PayPal account not verified. Please verify your PayPal account in the wallet settings before making payments.");const o=t(e(r,"transactions"),a("bookingId","==",y),a("type","==","payment"),a("paymentMethod","==","paypal"),a("status","==","completed"));if((await s(o)).empty)throw Error("PayPal payment not found. Please complete the PayPal payment first.")}else{if(m>I)throw Error(`Insufficient wallet balance. Required: ₱${m.toFixed(2)}, Available: ₱${I.toFixed(2)}. Please use PayPal to complete the payment.`);b=I-m,await i(n(r,"users",f),{walletBalance:b})}const k=.15*m,P=m-k;"wallet"===w&&await c({userId:f,type:"payment",amount:m,description:"Booking payment for booking #"+y.slice(0,8),status:"completed",paymentMethod:"wallet",bookingId:y,serviceFee:k,netAmount:P});const B=await o(n(r,"users",d.hostId));if(!B.exists())throw Error("Host user not found");const E=(B.data().walletBalance||0)+P;await i(n(r,"users",d.hostId),{walletBalance:E}),await c({userId:d.hostId,type:"deposit",amount:P,description:`Earnings from booking #${y.slice(0,8)} (after 15% service fee)`,status:"completed",bookingId:y,serviceFee:k,grossAmount:m}),await c({userId:"platform",type:"deposit",amount:k,description:"Service fee from booking #"+y.slice(0,8),status:"completed",paymentMethod:"service_fee",bookingId:y,guestId:f,hostId:d.hostId});try{const t=await o(n(r,"listing",d.listingId)),e=t.exists()?t.data().title:"Your booking";await u(f,y,e),await l(f,y,m,"completed")}catch(p){}return{success:!0,guestNewBalance:b,hostNewBalance:E,serviceFee:k,netToHost:P}}catch(f){throw f}},p=async(u,w,p)=>{try{const{guestId:m,hostId:y,totalPrice:g,id:h,status:I}=u;if(!(m&&y&&g&&g>0))throw Error("Invalid booking data for refund processing");const b=t(e(r,"transactions"),a("bookingId","==",h),a("type","==","payment"),a("status","==","completed"));if((await s(b)).empty&&"pending"===I)return{success:!0,refundAmount:0,message:"No payment was made for this pending booking"};const k=.15*g,P=g-k,[B,E]=await Promise.all([o(n(r,"users",m)),o(n(r,"users",y))]);if(!B.exists()||!E.exists())throw Error("User not found for refund processing");const x=B.data(),v=E.data(),A=x.walletBalance||0,$=v.walletBalance||0,F=A+g;await i(n(r,"users",m),{walletBalance:F});let N=$;P>$||(N=$-P,await i(n(r,"users",y),{walletBalance:N})),await c({userId:m,type:"refund",amount:g,description:`Refund for cancelled booking #${h.slice(0,8)} (cancelled by ${w})${p?": "+p:""}`,status:"completed",bookingId:h,cancelledBy:w}),P>$||await c({userId:y,type:"withdrawal",amount:P,description:"Refund deduction for cancelled booking #"+h.slice(0,8),status:"completed",bookingId:h,cancelledBy:w});const R=t(e(r,"transactions"),a("bookingId","==",h),a("type","==","deposit"),a("userId","==","platform"));(await s(R)).empty||await c({userId:"platform",type:"withdrawal",amount:k,description:"Service fee refund for cancelled booking #"+h.slice(0,8),status:"completed",bookingId:h,cancelledBy:w});try{const t=await o(n(r,"listing",u.listingId)),e=t.exists()?t.data().title:"Your booking";await d(m,h,e,w),await l(m,h,g,"refunded")}catch(f){}return{success:!0,guestNewBalance:F,hostNewBalance:N,refundAmount:g,serviceFeeRefund:k}}catch(m){throw m}},f=async(t,e,a)=>{try{if("refunded"===e.status)throw Error("Transaction has already been refunded");if("completed"!==e.status)throw Error("Only completed transactions can be refunded");const{userId:s,amount:d,type:l,bookingId:u}=e,w=await o(n(r,"users",s));if(!w.exists())throw Error("User not found");const f=w.data().walletBalance||0;if("payment"===l&&u){const t=await o(n(r,"bookings",u));if(t.exists()){const e={id:t.id,...t.data()};return await p(e,"admin",a)}}const m=f+d;return await i(n(r,"users",s),{walletBalance:m}),await c({userId:s,type:"refund",amount:d,description:`Refund for transaction #${t.slice(0,8)}${a?": "+a:""} (admin refund)`,status:"completed",originalTransactionId:t}),await i(n(r,"transactions",t),{status:"refunded",refundedAt:(new Date).toISOString(),refundReason:a}),{success:!0,newBalance:m,refundAmount:d}}catch(s){throw s}},m=async t=>{try{const e=await o(n(r,"transactions",t));if(!e.exists())throw Error("Transaction not found");const a=e.data();if("pending"!==a.status)throw Error("Only pending transactions can be confirmed");if("payment"===a.type&&a.bookingId){const t=await o(n(r,"bookings",a.bookingId));if(t.exists()){const e={id:t.id,...t.data()};await w(e)}}else{const t=await o(n(r,"users",a.userId));if(t.exists()){const e=(t.data().walletBalance||0)+("deposit"===a.type||"reward"===a.type?a.amount:-a.amount);await i(n(r,"users",a.userId),{walletBalance:e})}}return await i(n(r,"transactions",t),{status:"completed",confirmedAt:(new Date).toISOString()}),{success:!0}}catch(e){throw e}};export{w as a,f as b,m as c,p};
