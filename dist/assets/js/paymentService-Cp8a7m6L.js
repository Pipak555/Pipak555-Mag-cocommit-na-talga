const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/js/hostPointsService-D-CrRo9l.js","assets/js/firebase-vendor-BC71bXmb.js","assets/js/index-DaMaslBo.js","assets/js/react-vendor-Ve3SFwKO.js","assets/js/utils-vendor-DzY7Ay74.js","assets/js/maps-vendor-CYGXCXz5.js","assets/maps-vendor-Dgihpmma.css","assets/js/ui-vendor-D9RGQy8n.js","assets/js/icons-vendor-Dhca6XHc.js","assets/index-Bo0Pi70j.css"])))=>i.map(i=>d[i]);
import{j as t,z as a,Q as e,R as o,_ as s,S as n}from"./index-DaMaslBo.js";import{q as i,d as r,w as c,e as d,h as l,f as u,u as p}from"./firebase-vendor-BC71bXmb.js";const w=async(e,w="wallet")=>{try{const{guestId:h,totalPrice:I,id:k}=e;if(!h||!I||0>=I)throw Error("Invalid booking data for payment processing");const b=await l(u(t,"users",h));if(!b.exists())throw Error("Guest user not found");const P=b.data(),B=P.walletBalance||0;let E=B;if("paypal"===w){if(!P.paypalEmail)throw Error("PayPal account not linked. Please link your PayPal account in the wallet settings before making payments.");if(!P.paypalEmailVerified)throw Error("PayPal account not verified. Please verify your PayPal account in the wallet settings before making payments.");const a=i(r(t,"transactions"),c("bookingId","==",k),c("type","==","payment"),c("paymentMethod","==","paypal"),c("status","==","completed"));if((await d(a)).empty)throw Error("PayPal payment not found. Please complete the PayPal payment first.")}else{if(I>B)throw Error(`Insufficient wallet balance. Required: ₱${I.toFixed(2)}, Available: ₱${B.toFixed(2)}. Please use PayPal to complete the payment.`);E=B-I,await p(u(t,"users",h),{walletBalance:E})}const v=.1*I,x=I-v;"wallet"===w&&await a({userId:h,type:"payment",amount:I,description:"Booking payment for booking #"+k.slice(0,8),status:"completed",paymentMethod:"wallet",bookingId:k,serviceFee:v,netAmount:x});const S=await l(u(t,"users",e.hostId));if(!S.exists())throw Error("Host user not found");const F=(S.data().walletBalance||0)+x;await p(u(t,"users",e.hostId),{walletBalance:F}),await a({userId:e.hostId,type:"deposit",amount:x,description:`Earnings from booking #${k.slice(0,8)} (after 10% service fee)`,status:"completed",bookingId:k,serviceFee:v,grossAmount:I,payoutStatus:"pending"});try{const{awardHostPointsForBooking:t}=await s(async()=>{const{awardHostPointsForBooking:t}=await import("./hostPointsService-D-CrRo9l.js");return{awardHostPointsForBooking:t}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]));await t(e.hostId,k,I)}catch(f){}let A;try{const a=await l(u(t,"adminSettings","paypal"));a.exists()&&(A=a.data().paypalEmail)}catch(m){}const $=A?`Service fee from booking #${k.slice(0,8)} → ${A}`:`Service fee from booking #${k.slice(0,8)} (to admin PayPal account)`;if(await a({userId:"platform",type:"deposit",amount:v,description:$,status:"completed",paymentMethod:"service_fee",bookingId:k,guestId:h,hostId:e.hostId,adminPayPalEmail:A,originalPaymentMethod:w,payoutStatus:"pending"}),e.couponCode&&P.coupons)try{const a=P.coupons.map(t=>t.code!==e.couponCode||t.used?t:{...t,used:!0,usedAt:(new Date).toISOString(),usedForBookingId:k});await p(u(t,"users",h),{coupons:a})}catch(y){}try{const e=P.points||0,o=50,s=e+o;await p(u(t,"users",h),{points:s}),await a({userId:h,type:"reward",amount:o,description:"Points earned for booking #"+k.slice(0,8),status:"completed",bookingId:k})}catch(f){}try{const a=await l(u(t,"listing",e.listingId)),s=a.exists()?a.data().title:"Your booking";await n(h,k,s),await o(h,k,I,"completed")}catch(g){}return{success:!0,guestNewBalance:E,hostNewBalance:F,serviceFee:v,netToHost:x}}catch(m){throw m}},f=async(s,n,w)=>{try{const{guestId:y,hostId:g,totalPrice:h,id:I,status:k}=s;if(!(y&&g&&h&&h>0))throw Error("Invalid booking data for refund processing");const b=i(r(t,"transactions"),c("bookingId","==",I),c("type","==","payment"),c("status","==","completed"));if((await d(b)).empty&&"pending"===k)return{success:!0,refundAmount:0,message:"No payment was made for this pending booking"};const P=.1*h,B=h-P,[E,v]=await Promise.all([l(u(t,"users",y)),l(u(t,"users",g))]);if(!E.exists()||!v.exists())throw Error("User not found for refund processing");const x=E.data(),S=v.data(),F=x.walletBalance||0,A=S.walletBalance||0;if(s.couponCode&&x.coupons)try{const a=x.coupons.map(t=>t.code===s.couponCode&&t.used&&t.usedForBookingId===I?{...t,used:!1,usedAt:void 0,usedForBookingId:void 0}:t);await p(u(t,"users",y),{coupons:a})}catch(f){}const $=F+h;await p(u(t,"users",y),{walletBalance:$});let R=A;B>A||(R=A-B,await p(u(t,"users",g),{walletBalance:R})),await a({userId:y,type:"refund",amount:h,description:`Refund for cancelled booking #${I.slice(0,8)} (cancelled by ${n})${w?": "+w:""}`,status:"completed",bookingId:I,cancelledBy:n}),B>A||await a({userId:g,type:"withdrawal",amount:B,description:"Refund deduction for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:n});const _=i(r(t,"transactions"),c("bookingId","==",I),c("type","==","deposit"),c("userId","==","platform"));(await d(_)).empty||await a({userId:"platform",type:"withdrawal",amount:P,description:"Service fee refund for cancelled booking #"+I.slice(0,8),status:"completed",bookingId:I,cancelledBy:n});try{const a=await l(u(t,"listing",s.listingId)),i=a.exists()?a.data().title:"Your booking";await e(y,I,i,n),await o(y,I,h,"refunded")}catch(m){}return{success:!0,guestNewBalance:$,hostNewBalance:R,refundAmount:h,serviceFeeRefund:P}}catch(y){throw y}},m=async(e,o,s)=>{try{if("refunded"===o.status)throw Error("Transaction has already been refunded");if("completed"!==o.status)throw Error("Only completed transactions can be refunded");const{userId:n,amount:i,type:r,bookingId:c}=o,d=await l(u(t,"users",n));if(!d.exists())throw Error("User not found");const w=d.data().walletBalance||0;if("payment"===r&&c){const a=await l(u(t,"bookings",c));if(a.exists()){const t={id:a.id,...a.data()};return await f(t,"admin",s)}}const m=w+i;return await p(u(t,"users",n),{walletBalance:m}),await a({userId:n,type:"refund",amount:i,description:`Refund for transaction #${e.slice(0,8)}${s?": "+s:""} (admin refund)`,status:"completed",originalTransactionId:e}),await p(u(t,"transactions",e),{status:"refunded",refundedAt:(new Date).toISOString(),refundReason:s}),{success:!0,newBalance:m,refundAmount:i}}catch(n){throw n}},y=async a=>{try{const e=await l(u(t,"transactions",a));if(!e.exists())throw Error("Transaction not found");const o=e.data();if("pending"!==o.status)throw Error("Only pending transactions can be confirmed");if("payment"===o.type&&o.bookingId){const a=await l(u(t,"bookings",o.bookingId));if(a.exists()){const t={id:a.id,...a.data()};await w(t)}}else{const a=await l(u(t,"users",o.userId));if(a.exists()){const e=(a.data().walletBalance||0)+("deposit"===o.type||"reward"===o.type?o.amount:-o.amount);await p(u(t,"users",o.userId),{walletBalance:e})}}return await p(u(t,"transactions",a),{status:"completed",confirmedAt:(new Date).toISOString()}),{success:!0}}catch(e){throw e}};export{w as a,m as b,y as c,f as p};
